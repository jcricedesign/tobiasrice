<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flow Field Screensaver</title>
  <style>
    html, body { height: 100%; margin: 0; background:#06070a; overflow: hidden; }
    canvas { display:block; width:100vw; height:100vh; cursor: pointer; }
    .hint {
      position: fixed; left: 14px; bottom: 14px;
      font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: rgba(255,255,255,.55);
      user-select: none;
      background: rgba(0,0,0,.25);
      padding: 8px 10px;
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 10px;
      backdrop-filter: blur(6px);
    }
    .hint b { color: rgba(255,255,255,.8); font-weight: 600; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hint">
    Click for <b>fullscreen</b> · Press <b>F</b> to toggle · <b>Esc</b> exits<br/>
    Move mouse to “magnetize” the field
  </div>

  <script>
    // --- Canvas setup (HiDPI) ---
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha: false });
    let W = 0, H = 0, DPR = 1;

    function resize() {
      DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // cap for performance
      W = Math.floor(window.innerWidth * DPR);
      H = Math.floor(window.innerHeight * DPR);
      canvas.width = W;
      canvas.height = H;
      ctx.setTransform(1,0,0,1,0,0);
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      // Start with a dark fill
      ctx.fillStyle = "#06070a";
      ctx.fillRect(0, 0, W, H);
    }
    window.addEventListener("resize", resize, { passive: true });
    resize();

    // --- Lightweight 2D value-noise (smooth pseudo-random field) ---
    function fract(x){ return x - Math.floor(x); }
    function hash2(x, y) {
      // Stable pseudo-random in [0,1)
      return fract(Math.sin(x * 127.1 + y * 311.7) * 43758.5453123);
    }
    function smoothstep(t){ return t * t * (3 - 2 * t); }
    function lerp(a,b,t){ return a + (b-a) * t; }

    function valueNoise(x, y) {
      const xi = Math.floor(x), yi = Math.floor(y);
      const xf = x - xi, yf = y - yi;
      const u = smoothstep(xf), v = smoothstep(yf);

      const n00 = hash2(xi, yi);
      const n10 = hash2(xi + 1, yi);
      const n01 = hash2(xi, yi + 1);
      const n11 = hash2(xi + 1, yi + 1);

      const nx0 = lerp(n00, n10, u);
      const nx1 = lerp(n01, n11, u);
      return lerp(nx0, nx1, v); // 0..1
    }

    function fbm(x, y) {
      // Fractal Brownian Motion: layered smooth noise
      let a = 0.5, f = 1.0, sum = 0, norm = 0;
      for (let i = 0; i < 4; i++) {
        sum += a * valueNoise(x * f, y * f);
        norm += a;
        a *= 0.5;
        f *= 2.0;
      }
      return sum / norm; // 0..1
    }

    // --- Flow field parameters ---
    const params = {
      fade: 0.065,           // trail persistence (lower = longer trails)
      fieldScale: 0.0016,    // spatial scale of field
      timeScale: 0.06,       // how fast the field evolves
      curl: 6.2,             // how tightly lines curve
      speed: 1.15,           // particle step speed
      count: 1600,           // number of particles
      jitter: 0.35,          // subtle hand-drawn wobble
      lineWidthMin: 0.6,
      lineWidthMax: 1.3
    };

    // --- Color palette: "colored pencil on dark paper" ---
    const palette = [
      [255, 210,  90], // warm yellow
      [140, 220, 255], // icy cyan
      [255, 140, 220], // pink
      [180, 255, 160], // mint
      [210, 170, 255]  // lilac
    ];
    function rgba(r,g,b,a){ return `rgba(${r|0},${g|0},${b|0},${a})`; }

    // --- Particles ---
    const particles = [];
    function rand(min, max){ return min + Math.random() * (max - min); }
    function resetParticle(p) {
      p.x = rand(0, W);
      p.y = rand(0, H);
      p.vx = 0; p.vy = 0;
      p.life = rand(200, 1400);
      p.hueShift = rand(-10, 10);
      const c = palette[(Math.random() * palette.length) | 0];
      p.base = c;
      p.w = rand(params.lineWidthMin, params.lineWidthMax) * DPR;
      p.alpha = rand(0.04, 0.12);
    }

    function initParticles() {
      particles.length = 0;
      for (let i = 0; i < params.count; i++) {
        const p = {};
        resetParticle(p);
        particles.push(p);
      }
    }
    initParticles();

    // --- Mouse influence ("magnetize") ---
    let mouseX = W * 0.5, mouseY = H * 0.5, mouseActive = false;
    window.addEventListener("mousemove", (e) => {
      mouseX = e.clientX * DPR;
      mouseY = e.clientY * DPR;
      mouseActive = true;
    }, { passive: true });
    window.addEventListener("mouseleave", () => { mouseActive = false; }, { passive: true });

    // --- Fullscreen toggle ---
    async function toggleFullscreen() {
      try {
        if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
        else await document.exitFullscreen();
      } catch (_) {}
    }
    canvas.addEventListener("click", toggleFullscreen);
    window.addEventListener("keydown", (e) => {
      if (e.key.toLowerCase() === "f") toggleFullscreen();
    });

    // --- Field function: angle from noise (smooth + evolving) ---
    let t0 = 0;
    function fieldAngle(x, y, t) {
      // Normalize space for noise
      const nx = x * params.fieldScale;
      const ny = y * params.fieldScale;

      // Evolving noise: fbm + time offset
      const n = fbm(nx + t * params.timeScale, ny - t * params.timeScale);

      // "Curl" it into an angle
      let a = (n * Math.PI * 2) * params.curl;

      // Mouse adds a gentle swirl / attraction
      if (mouseActive) {
        const dx = mouseX - x, dy = mouseY - y;
        const dist2 = dx*dx + dy*dy;
        const influence = Math.min(1, 120000 / (dist2 + 120000)); // smooth falloff
        const swirl = Math.atan2(dy, dx) + Math.PI / 2;
        a = lerp(a, swirl, 0.22 * influence);
      }
      return a;
    }

    // --- Render loop ---
    function step() {
      t0 += 1;

      // Fade the frame slightly to create trails
      ctx.fillStyle = `rgba(6,7,10,${params.fade})`;
      ctx.fillRect(0, 0, W, H);

      // Pencil-like strokes: normal blend + low alpha; slight jitter
      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        const x0 = p.x, y0 = p.y;

        const a = fieldAngle(p.x, p.y, t0);

        // Step with subtle wobble to feel "hand drawn"
        const jx = (Math.random() - 0.5) * params.jitter * DPR;
        const jy = (Math.random() - 0.5) * params.jitter * DPR;

        const vx = Math.cos(a) * params.speed * DPR;
        const vy = Math.sin(a) * params.speed * DPR;

        p.x += vx + jx;
        p.y += vy + jy;

        // Draw a segment
        const [r,g,b] = p.base;
        ctx.strokeStyle = rgba(r, g, b, p.alpha);
        ctx.lineWidth = p.w;

        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(p.x, p.y);
        ctx.stroke();

        // Life + bounds
        p.life -= 1;
        if (p.life <= 0 || p.x < -20 || p.x > W + 20 || p.y < -20 || p.y > H + 20) {
          resetParticle(p);
        }
      }

      requestAnimationFrame(step);
    }
    step();

    // If you resize after init, keep particles count but refresh positions slightly
    window.addEventListener("resize", () => {
      // Re-seed a portion so it fills new area quickly
      for (let i = 0; i < particles.length; i++) {
        if (Math.random() < 0.35) resetParticle(particles[i]);
      }
    }, { passive: true });
  </script>
</body>
</html>